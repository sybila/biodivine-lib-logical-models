    pub fn transition_under_variable(
        &self,
        transitioned_variable_name: &str,
        current_state: &Bdd,
    ) -> Bdd {
        let domain = self
            .named_symbolic_domains
            .get(transitioned_variable_name.clone())
            .unwrap_or_else(|| panic!("could not find variable {}", transitioned_variable_name));

        let const_false = current_state.and(&current_state.not()); // used as the start of the fold

        domain
            .get_all_possible_values(&self.variable_set)
            .into_iter()
            .fold(const_false, |acc, possible_value| {
                // todo the fact that you have to query two hashmaps with the variables name to get the domain & the update fn suggests it should be refactored
                let update_fn = self
                    .update_fns
                    .get(transitioned_variable_name.clone())
                    .unwrap();

                // todo this one should likely store the domain (and the name?) of the variable it is updating
                // todo  because there is some tight coupling between the order of the bit_updating_bdds in update_fn
                // todo  and the domain (specifically how the domain encodes given value into (bdd) bits)
                // update_fn.bit_answering_bdds[0].0.ev;

                let bits_of_the_encoded_value = domain.encode_bits_into_vec(possible_value);

                // todo assert the len of the `bits_encoded_value` == count of bdds in `bit_answering_bdds`

                let vars_and_their_bits = domain
                    .symbolic_variables()
                    .into_iter()
                    .zip(bits_of_the_encoded_value.clone())
                    .collect::<Vec<_>>();

                let const_true = current_state.or(&current_state.not());
                let any_that_does_not_have_the_same_value =
                    const_true.restrict(&vars_and_their_bits);

                let states_capable_of_transitioning_into_given_value = update_fn
                    .bit_answering_bdds
                    .iter()
                    .map(|(bit_answering_bdd, _)| bit_answering_bdd)
                    .zip(bits_of_the_encoded_value.iter().cloned())
                    .fold(
                        any_that_does_not_have_the_same_value,
                        |acc, (ith_bit_answering_bdd, ith_expected_bit)| {
                            if ith_expected_bit {
                                acc.and(ith_bit_answering_bdd)
                            } else {
                                acc.and(&ith_bit_answering_bdd.not())
                            }
                        },
                    );

                // this restriction should "perform the transition"
                let states_transitioned_into_given_value =
                    states_capable_of_transitioning_into_given_value
                        .restrict(&vars_and_their_bits[..]);

                acc.or(&states_transitioned_into_given_value)
            })
    }